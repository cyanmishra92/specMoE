=== ORIGINAL PDF: 2505.02181v1_Efficient_FPGA_Implementation_of_Time-Domain_Popco.pdf ===\n\nRaw text length: 46125 characters\nCleaned text length: 45835 characters\nNumber of segments: 25\n\n=== CLEANED TEXT ===\n\narXiv:2505.02181v1 [cs.LG] 4 May 2025 PREPRINT - Accepted at IEEE International Symposium on Asynchronous Circuits and Systems (ASYNC) 2025 Efficient FPGA Implementation of Time-Domain Popcount for Low-Complexity Machine Learning Shengyu Duan , Marcos L. L. Sartori , Rishad Shafik , Alex Yakovlev , Emre Ozer Microsystems Research Group, Newcastle University, Newcastle upon Tyne, UK Pragmatic Semiconductor, Cambridge, UK {shengyu.duan, marcos.sartori, rishad.shafik, alex.yakovlev}.newcastle.ac.uk Abstract Population count (popcount) is a crucial operation for many low-complexity machine learning (ML) algorithms, in- cluding Tsetlin Machine (TM)-a promising new ML method, par- ticularly well-suited for solving classification tasks. The inference mechanism in TM consists of propositional logic-based structures within each class, followed by a majority voting scheme, which makes the classification decision. In TM, the voters are the outputs of Boolean clauses. The voting mechanism comprises two operations: popcount for each class and determining the class with the maximum vote by means of an argmax operation. While TMs offer a lightweight ML alternative, their per- formance is often limited by the high computational cost of popcount and comparison required to produce the argmax result. In this paper, we propose an innovative approach to accelerate and optimize these operations by performing them in the time domain. Our time-domain implementation uses programmable delay lines (PDLs) and arbiters to efficiently manage these tasks through delay-based mechanisms. We also present an FPGA design flow for practical implementation of the time-domain popcount, addressing delay skew and ensuring that the behavior matches that of the model s intended functionality. By leveraging the natural compatibility of the proposed popcount with asyn- chronous architectures, we demonstrate significant improvements in an asynchronous TM, including up to 38 reduction in latency, 43.1 reduction in dynamic power, and 15 savings in resource utilization, compared to synchronous TMs using adder- based popcount. Index Terms Popcount, Machine Learning, Tsetlin Machine, Programmable Delay Line, FPGA. I. INTRODUCTION There has been a shift towards low-complexity machine learning (ML) algorithms, offering competitive performance with fewer resources than deep neural networks. Tsetlin Ma- chines (TMs) [1] and Binarized Neural Networks (BNNs) [2] are two prominent alternatives that leverage bit-wise oper- ations, making them highly suitable for implementation on Field Programmable Gate Arrays (FPGAs). A TM is inherently logic-based, performing classification through propositional logic with Boolean inputs (Fig. 1 (a)). In contrast, a BNN represents an extreme case of quantized deep neural networks, encoding values with a single bit ( 1 -1) and simplifying multiplications using XNOR operations (Fig. 1 (b)). Population count (otherwise known as popcount) and com- parison (argmax) are critical operations in both TMs and Class 1 Input vector: [x0 x1] Class 0 x0 x0 x1 x1 x0 x0 x1 x1 x0 x0 x1 x1 x0 x0 x1 x1 Clauses 1 -1 1 -1 P Popcount x: Include x: Exclude ... Argmax ... Predicted class (a) Input vector [x0 x1 ...] ... 1 P Popcount Sign Output (b) Fig. 1: (a) TMs, where each TM is assigned to a certain class and each clause has been trained to recognize a pattern of Boolean inputs, represented by propositional logic. Popcount counts the number of clauses supporting ( 1) and opposing (-1) each class, with the classification determined by the class with the highest popcount, using argmax. (b) A BNN neuron. x0 and x1 are input features or activation values. BNNs. In a TM, these operations function as a majority vote mechanism to determine classification outcomes (Fig. 1 (a)). On the other hand, in a BNN, popcount serves as the accumulation function for each neuron, followed by a comparator that applies the sign function by comparing the result to zero for activation (Fig. 1 (b)). However, studies have identified popcount and comparison as bottlenecks in BNN implementations, increasing latency and resource consumption due to their relatively low hardware efficiency compared to logic operations [3], [4]. For the first time, we will present these operations as bottlenecks for TMs in Section IV. To overcome this bottleneck, some efforts have been dedi- cated to developing cost-efficient and high-performance pop- count accelerators and compressors, with a primary focus on adder-based architectures [4] [7]. In this paper, we introduce a paradigm shift by transitioning popcount and argmax oper- ations to the time domain. For ML algorithms including TMs and BNNs, the core functionality remains unaffected by this transformation, as their outputs are typically determined by relative magnitudes rather than absolute values. The basic principle of our method is as follows: the higher the popcount the smaller the delay of the corresponding delay- line. This combination of time-domain functionality naturally suits the use of asynchronous logic design. To implement this 1 method in FPGA, we use programmable delay lines (PDLs), constructed using Lookup Tables (LUTs), to function as popu- lation counters (pop counters), while arbiters are employed as comparators that respond based on signal arrival times. This operation s output is one-hot, and computations are interleaved with spacers, making the use of completion detectors the natural choice. Furthermore, we propose a design flow for placement, pin assignment, and routing of PDLs to mitigate delay skew introduced by generic FPGA implementations. We leverage this advantage to design asynchronous cir- cuit for the TM inference using MOUSETRAP [8] on a Xilinx Zynq XC7Z020 FPGA (PYNQ-Z1), using a single- rail bundled datapath and two-phase handshake protocol. Our case study demonstrates a low latency and energy-efficient inference process for asynchronous TMs, achieved through the implementation of time-domain popcount. This results in enhanced throughput (up to 38 lower latency), reduced power consumption (up to 43.1 less power), and lower resource utilization (up to 15 less) compared to conventional adder-based popcount implementations, particularly for multi- class classification tasks that involve comparisons across many entities. We make the following key contributions: A novel time-domain circuit design for popcount and comparison, enabling cost-efficient and scalable imple- mentations for TMs and possibly BNNs. A FPGA design flow for implementing time-domain popcount, addressing propagation delay uncertainties to ensure reliable and efficient performance. High-performance asynchronous architectures for TMs with time-domain pop counters and comparators, signif- icantly improving throughput and power efficiency. The paper is organized as follows: Section II reviews related work on popcount circuits and PDLs. Section III presents our time-domain popcount and comparison design and FPGA implementation flow. Section IV showcases an asynchronous TM case study, compares it with existing approaches. Section V concludes the paper and outlines future work. II. RELATED WORK We overview state-of-the-art digital popcount designs and PDLs, focusing on their suitability for FPGA implementation. A. Popcount Conventional popcount designs primarily rely on binary full adder trees to sum input bits. Recent research has largely focused on optimizing wide adders, while efforts to accelerate or compress popcount adders remain limited. One improve- ment is an 8-bit popcount design that reduces resource usage [9]. However, for longer input vectors, this approach requires additional levels to aggregate multiple 8-bit popcount results, ultimately leading to a tree-based adder architecture. A more recent approach leverages 6-input LUTs in mod- ern FPGAs to compress popcount trees, where three LUTs collectively function as a 6-bit popcounter, producing a 3-bit output [10]. Another design, optimized based on ripple carry adders, introduces an additional chain to propagate the sum of each full adder [6]. While this method achieves modest resource savings, it increases latency compared to conventional popcount trees. Further optimizations based on these works have been proposed by sharing logic elements [5], [7]. Most existing adder-based approaches remain within a sim- ilar design space, where improving one metric typically comes at the expense of others. More importantly, the comparison of multiple popcount results an essential operation in applica- tions such as TMs and the output layer of BNNs introduces significant overhead in terms of latency and resource con- sumption when using digital comparators [11]. In ML tasks involving a large number of classes, this comparison (argmax) becomes a major bottleneck. B. Programmable Delay Line (PDL) PDLs have been practically implemented on FPGAs in previous works, utilizing a cascade of programmable delay elements, where each element consists of a single LUT that buffers or inverts an input signal with its delay multiplexed by other inputs [12] [15]. These PDLs are commonly used for arbiter physical unclonable functions (PUFs), which compare signals racing through two symmetric PDLs and generate responses based on cumulative delays of all units in each path. However, PDLs originally for arbiter PUFs cannot be di- rectly applied for time-domain popcount. First, PUF outputs are determined by specific input vector, whereas popcount outputs depend on input Hamming weight; for example, the output should remain the same for input vectors 0...01 and 10...0 in popcount, which is not the case for PUFs. Second, while PUFs exploit intrinsic process variations to generate device-specific responses, popcount must mitigate these variations for consistency and device-independency. A recent study proposed using PDLs specifically for TM popcount followed by asynchronous arbitration for argmax [16]. However, this work lacks validation through physical implementation of integrated circuit or FPGA. We emphasize that achieving accurate popcount using PDLs requires both structural and physical uniformity, the latter of which can only be ensured through careful physical design. On FPGAs, rout- ing delays dominate over logic delays, necessitating precise placement and routing to maintain an unskewed relationship between input Hamming weight and popcount. This effort is crucial for the deployment of PDLs for popcount. III. TIME-DOMAIN POPCOUNT ON FPGA A. Time-domain Popcount and Comparison We present the overall architecture for the time-domain popcount and comparison in Fig. 2. 1) Overall operational mechanism: The core concept be- hind the time-domain popcount and comparison design is as follows. Each PDL functions as a converter, transforming a binary code (input vector) into a cumulative delay (popcount result) based on its corresponding Hamming weight. As illustrated in Fig. 2, when comparing the popcount of two binary codes, these codes are represented by the signals 2 High-latency net Low-latency net D Q 0 1 S up[0] ... 0 1 S up[n-1] PDL Output D Q 0 1 S lo[0] ... 0 1 S lo[n-1] Delay element Arbiter Start Completion I0 0 1 1 1 INIT[7:0]: 0 1 0 0 0 1 1 0 0 1 1 0 I1 0 1 0 1 I2 0 1 output LUT select Configurable delay skew A1 A2 A3 A4 A5 A6 400 600 800 1,000 1,013 811 648 774 414 355 Physical pin Minimal net delay (ps) Physical pin assignment for logical pin I0 I1 Fig. 2: Time-domain popcount and comparison, implemented by PDL and arbiter, respectively. S up and S lo, corresponding to the upper and lower PDLs, respectively. Each bit in these codes is processed using two elementary delay units: one long (high-latency net) and one short (low-latency net). The delay path selects either the longer or shorter delay unit via a multiplexer: a bit of S up S lo equal to 0 1 inserts the longer shorter delay unit. Once all input binary codes are valid and ready for conver- sion, a start signal propagates from the left to the right end of all PDLs. The delay incurred by each PDL is inversely proportional to the Hamming weight of its corresponding binary code. In other words, a binary code with a higher popcount reaches the end earlier than one with a lower popcount. The arrival times at the right ends of the two PDLs are captured by an arbiter, implementing an argmax operation. Specifically, in the case of TMs, the input binary code for a PDL is derived from the outputs of all clauses belonging to a particular class. As shown in Fig. 1 (a), half of the clauses vote for the class, while the other half vote against it. To handle this polarity within a single PDL, an input bit from a clause supporting the class (positive clause) selects the longer shorter delay unit if it is 0 1 , whereas for a clause opposing the class (negative clause), the selection is reversed: a 1 0 input inserts the longer shorter delay unit. 2) PDL: Time-domain popcount is implemented using PDLs consisting of cascaded delay elements, each realized with a single LUT, similar to [12] [15]. However, our design places a strong emphasis on ensuring structurally symmetric PDLs and physically identical delay elements. Across all PDLs, the start signal triggered by a rising or falling transition is synchronized using D flip-flops (FFs) running at the maximum clock frequency. This synchroniza- tion is essential, as the input transition may be distributed across a large number of PDLs, which otherwise leads to uneven signal propagation. The potential skew caused by fan- out is mitigated by allowing the transition to propagate only at the clock edge, which is uniformly distributed to all FFs through clock tree synthesis. Each delay element is implemented by configuring a LUT to function as a multiplexer with two inputs, both connected to the output of the preceding logic. These two inputs have different propagation delays, realized by routing them through high-latency and low-latency nets, respectively, as described in Section III-B. We emphasize that a specific logical pin mapping process is required to assign the inputs to physical pins, particularly for Xilinx FPGAs, where pins A6 and A5 are faster than the others, as reported in [17]. To validate this, we evaluate the minimal net delay for all physical pins using Vivado, as shown in Fig. 2, to determine the optimal pinout selection: the low-latency and high-latency nets are assigned to the fastest and second-fastest physical pins, respectively. The delay of the high-latency net is then adjusted during the routing phase to minimize the delay difference relative to the low- latency net, achieving minimal overall latency while ensuring adequate granularity and resolution for the task. 3) Arbiter: A NAND SR latch is employed as the arbiter to respond to the race between two PDLs, outputting 0 or 1 based on which chain introduces the rising transition first. The latch, constructed from two cross-coupled NAND gates, ensures symmetric placement relative to the two PDLs. An OR gate generates a completion signal to indicate the comparison is complete. For comparisons involving more than two PDLs, additional levels of arbiters are added, with the completion signal from the previous level serving as input to the next. For falling transitions, a separate arbiter is used, comprising a NOR SR latch and an AND gate to produce the comparison result and completion signal, respectively. Metastability may occur if two PDLs trigger output tran- sitions at nearly the same time. However, this can usually be resolved by increasing the delay difference between high- and low-latency nets of all delay elements, which improves resolution and ensures a sufficient gap between the transition arrival times, even when the two PDLs receive a nearly identical (but not the same) ones from their corresponding input vectors. Therefore, metastability may only occur if two PDLs receive equal number of ones (same Hamming weight). For certain ML operations like argmax, where two inputs are identical, the argmax function is designed to either arbitrarily select one input or consistently return a specific index. In both cases, this might be interpreted as an incorrect decision, as the result would essentially be based on a random or predetermined guess (basically, the result of inference may not match the class label in the training set)1. B. Implementation We present the FPGA implementation flow for the time- domain popcount design in Fig. 3. While some steps require manual intervention, these can be performed using the example 1The discussion of the interpretation of the classification metastability is outside the scope of this paper. It is worth noting that the problem of non- unique classification using argmax is sometimes mitigated by the techniques such as Softmax and Softermax [18]. 3 Tcl scripts provided as references. Each step is repeated for every delay element. Placement Place delay element in specified site and slice set property BEL D6LUT [get cells PDL0 0 MUX] set property LOC SLICE X74Y0 [get cells PDL0 0 MUX] Example scripts Pin Assignment Map logical pins to physical pins set property LOCK PINS {I1:A6 I0:A5} [get cells PDL0 0 MUX] Example scripts Routing route design -unroute Remove existing routing Delay-driven routing for consistent delay skew route design -pins [get pins PDL0 0 MUX I1] -max delay 500 route design -pins [get pins PDL0 0 MUX I0] -max delay 800 -min delay 700 route design -preserve Preserve existing routing; route the rest set property is route fixed 1 [get nets PDL0 0 I1 PDL0 0 I0] Fix routing Example scripts Fig. 3: Implementation flow for time-domain popcount with example Xilinx Tcl scripts. 1) Placement: FPGAs consist of numerous identical logic components, which we utilize to implement uniform PDLs and delay elements. Symmetric PDLs are achieved by mapping them onto identical geometric components. Fig. 4 illustrates an example of placement on Xilinx FPGA, where PDLs are aligned vertically, with each delay element assigned to a configurable logic block (CLB). Alternative geometric place- ments are also possible, as long as the symmetry of the PDLs is preserved. Similarly, the cross-coupled NAND gates in an arbiter must be symmetrically positioned relative to the corresponding PDLs. This placement strategy increases the likelihood of achieving identical routing in later design stages. Furthermore, two cascaded delay elements are placed in adjacent CLBs, minimizing the geometric distance between them to reduce net delay for their interconnections. LUTs Slice CLB Switchbox PDL : Delay element PDL Fig. 4: PDL placement on Xilinx FPGA, where each CLB consists of two slices, and each slice contains four LUTs. Each PDL is mapped to CLBs positioned identically relative to their neighboring switchboxes. Delay elements are consistently placed in the same relative position, specifically within a designated LUT in a particular slice of each CLB. 2) Pin assignment: As explained in Section III-A 2), the inputs with low- and high-latency nets of a delay element are initially mapped to the fastest and second-fastest physical pins of a LUT, respectively. This minimizes overall latency and ensures sufficient delay resolution during the routing process. 3) Routing: For each delay element, we route the low- and high-latency nets by specifying the delay range, as shown in Fig. 3. With all delay elements placed at identical geometric positions within their respective CLBs and cascaded delay elements aligned relative to each other, applying the same delay ranges ensures symmetric routing across all PDLs and uniform routing for all delay elements within each PDL. This is demonstrated in Fig. 5, captured from Vivado device view for two implemented PDLs, with routing paths highlighted. For each arbiter s two NAND gates, we specify identical physical pins, and apply the same delay constraints for routing. Similarly, we impose equal delay constraints on both inputs of each NAND gate. PDL CLBLL L X68Y0 CLBLL L X68Y1 CLBLL L X68Y2 INT L X68Y0 INT L X68Y1 INT L X68Y2 INT R X69Y0 INT R X69Y1 INT R X69Y2 CLBLL L X70Y0 CLBLL L X70Y1 CLBLL L X70Y2 INT L X70Y0 INT L X70Y1 INT L X70Y2 CLBLM R X69Y0 CLBLM R X69Y1 CLBLM R X69Y2 Fig. 5: Symmetric PDL and delay element layout. 4) Evaluation of Hamming weight response: An ideal time-domain popcount requires a monotonically decreasing propagation delay through the PDL as the input Hamming weight increases. We assess the likelihood of achieving this monotonic behavior in a practical implementation, considering the impact of process and environmental variations. Specifically, we implement a PDL with 150 delay elements using the proposed design flow and measure its overall propa- gation delay on an FPGA board. The measurement follows the delay characterization method from [19], with varying input Hamming weights. Fig. 6 presents the measured delays for two PDLs, where the delay difference between the low- and high-latency nets is set to approximately 60 ps and 600 ps. For each case, we compute Spearman s rank correlation coefficient (Spearman s ρ), where -1 1 indicates a perfectly decreasing increasing monotonic function. As shown, both cases exhibit a highly linear delay reduction as the Hamming weight increases, with Spearman s ρ extremely close to -1. Furthermore, increasing the delay difference between the low- and high-latency nets further strengthens the monotonicity. While a perfect linear relationship between delay and Ham- ming weight is impossible due to intra-die process, voltage 4 0 20 40 60 80 100 120 140 20 30 40 50 60 Hamming weight Propagation delay (ns) Delay difference: 60 ps, Spearman s ρ -0.9897 Delay difference: 600 ps, Spearman s ρ -0.9981 140 145 150 21 22 23 24 Fig. 6: PDL propagation delay vs. input Hamming weight. and temperature variations, the time-domain popcount can maintain sufficient accuracy by appropriately tuning the delay difference, with a trade-off in overall propagation delay as needed. IV. TM CASE STUDY A. Asynchronous TM with Time-Domain Popcount For the time-domain popcount presented, the critical path is determined by all delay elements with their corresponding high-latency nets, meaning the worst-case delay is primarily influenced by the cumulative delay of the high-latency nets. In tasks requiring high-accuracy popcount, the high-latency net delay must be increased to mitigate metastability in the arbiter and ensure sufficient timing resolution for the PDL. This increase in delay, however, leads to increased latency and reduced throughput when the time-domain popcount is used in a synchronous design. Fortunately, the time-domain popcount design is naturally compatible with an asynchronous handshake protocol. The input transition of a PDL can be triggered directly by a single-bit request, while the output of either the PDL or the arbiter can be used to generate an acknowledgement or a new request, enabling the next actions with minimal additional control logic. In this configuration, the overall latency depends on the specific input vectors for the PDLs, rather than being constrained by the worst-case delay. We present a single-rail, 2-phase asynchronous architecture for TM inference, incorporating the MOUSETRAP stage cir- cuit [8] with the time-domain popcount, as shown in Fig. 7, for the case study. This configuration enables high-speed operation through 2-phase handshaking and strong FPGA compatibility using simple logic gates for the control. Additionally, the time- domain popcount can be integrated with other asynchronous or self-timed architectures, as it effectively functions as a buffer for propagating control signals, whether level-sensitive or transition-based. In Fig. 7, the processing logic following the transparent latches consists of TM clause blocks responsible for propo- sitional logic computations, as shown in Fig. 1 (a). We adopt a bundled-data scheme for these clause computation blocks, Data latch En done req Bit latch ack delay Input vector Class 0 clauses Class 1 clauses Class 2 clauses Q D ... Select Q D ... Select Q D ... Select PDL PDL output const 0 1 Completion Output Input up Input lo Completion Output Input up Input lo Arbiter Completion Output Input up Input lo Completion Asynchronous controller Fig. 7: Asynchronous TM architecture, integrating a MOUSE- TRAP stage and time-domain popcount and comparison. requiring a bundling signal based on their worst-case delay. In FPGA, this bundling signal can be generated by appropriately setting a net delay, eliminating the need for additional logic. Each PDL receives outputs from a TM clause block for a specific class, with the bundling signal acting as the input transition. The clause output selects whether the propagation path follows the low- or high-latency net of a delay element. As explained in Section III-B, the connections of the low- and high-latency nets are swapped at the delay element inputs to account for clauses with positive and negative polarity. Fig. 7 illustrates a TM with three classes, requiring two lev- els of arbiters. At the first level, the lower arbiter has one input fixed at either 0 or 1, depending on whether req undergoes a rising or falling transition in a given cycle. This ensures the arbiter is only sensitive to the incoming PDL output while maintaining a symmetric arbiter tree structure. For TMs with more classes, additional arbiter levels are required. The final classification is obtained by decoding the arbiter outputs, with the last-level arbiter generating the Completion signal. The architecture features a single MOUSETRAP stage for the present single-layer TMs. done signal toggles req to initi- ate a new inference process, enabling support for batched data. A simple asynchronous controller generates ack, switching the latches from opaque to transparent based on Completion and all PDL outputs, as explained later in this section. Notably, this architecture can be adapted for a pipelined design with minimal modifications: done serves as the acknowledgment signal for the previous stage, while the asynchronous controller generates the request signal for the next pipeline stage. We specify the overall operation using a signal transition graph (STG), shown in Fig. 8. The signal transitions and their causal relationships are partially realized by the MOUSE- TRAP control (see [8]). In our design, a merge fragment based on all PDL outputs that provides the Completion signal is implemented using arbiters. A transition in the Completion triggers a change in a wait signal in the asynchronous con- troller. This wait signal temporarily halts operations until the appropriate transitions are received at all PDL outputs, as managed by a join fragment. This suspension prevents unarrived transitions from interfering with the next inference cycle. Given that sufficient timing resolution has been achieved by appropriately setting the delay differences for the delay ele- ment inputs, the falling and rising transitions of the wait signal 5 can always be met by the timing. Note that for each inference, the overall latency is determined by the TM producing the smallest class sum; however, in practice, it rarely reaches the worst-case scenario, where all delay elements propagate with the low-latency net, as demonstrated in Section IV-C. MOUSETRAP controller Popcount and asynchronous controller req done En- En ack PDL output 2 PDL output 1 PDL output 0 wait- Completion wait Fig. 8: STG for asynchronous TM, with the dotted arc as a mandatory timing dependency not enforced by the controller. B. Experimental Setup We validate the asynchronous TM using two datasets: Iris [20] and MNIST [21] (Table I). For each dataset, a Booleaniza- tion process is first applied to convert the raw features into a set of Boolean data [22]. For Iris, each raw feature is Booleanized into three Boolean features using quantile binning, represented as a three-bit one-hot encoding, resulting in a total of 12 Boolean features. For MNIST, it is performed by applying a threshold of 75 to all grayscale values. TABLE I: Dataset, TM model and PDL details. Dataset TM PDL net delaya (ps) Classes Boolean features Clausesb (T,s) Accuracy ( ) Low- latency High- latency Iris 3 12 10 (5,1.5) 96.7 375.4 641.9 50 (7,6.5) 90 388.6 593 MNIST 10 784 50 (5,7) 94.5 402.8 603.3 100 (5,10) 95.4 371.1 632.1 a Delay to realize lossless accuracy b Number of clauses per class For Iris and MNIST, we train two TMs with 10 and 50 clauses, and 50 and 100 clauses, respectively, to assess performance across varying numbers of classes and clauses, for evaluation purpose. Higher accuracy could be achieved by using more clauses [23]. The hyperparameters T and s for TM training are chosen based on the optimal accuracy setups from [23]. For PDLs, we set the low-latency net delay to the smallest possible value and adjust the high-latency net delay using trial and error to determine the minimum delay that ensures lossless accuracy. On average, the low- and high-latency net delays are 384.5 ps and 617.6 ps, respectively, with a 233.1 ps difference. We emphasize that the proposed architecture can be applied to implement TMs for any dataset, regardless of the number of classes, clauses, or features. The trends observed in design metrics as the model scales reported in the following section are applicable to datasets beyond Iris and MNIST. All designs were implemented on a Xilinx Zynq XC7Z020 FPGA (PYNQ-Z1), featuring 53,200 LUTs and 106,400 FFs in a 28 nm technology node. The proposed architecture is compared to the following state-of-the-art designs: Generic implementation A synchronous TM archi- tecture with adder-based popcount and comparison, syn- thesized and implemented using Vivado 2024.1 s generic process. FPT 18 [6] A synchronous FPGA-based popcount circuit, originally designed for BNNs, which we recon- structed within a TM architecture for evaluation. ASYNC 21 [24] A dual-rail asynchronous TM ar- chitecture using dual-rail 8-bit pop counters, originally presented in [9]. Since this circuit is not designed for FPGA and its implementation would require extensive modifications, we compare only resource utilization by evaluating the equivalent LUT count of their pop coun- ters, synthesizing their building blocks in Vivado. C. Evaluation and Comparison We present the inference latency, resource utilization (to- tal LUTs and FFs), and dynamic power for the evaluated implementations in Fig. 9. For resource utilization, we treat LUTs and FFs equally for simplicity, although in practice, their impact on area can vary depending on the design and FPGA architecture. For the two adder-based synchronous implementations, latency, defined as the minimal clock period, is determined by the worst-case critical path delay. For the proposed asynchronous design, latency is measured as the average inference time over 100 samples, as it is not controlled by clock. Resource utilization and dynamic power are obtained from the Vivado implementation reports. For each metric, we highlight the proportional contribution of the popcount and comparison operations. As shown in Fig. 9 (a), in all cases, the latency due to popcount and comparison dominates the overall inference latency, with the proportion contributed by these operations increasing significantly as the model scales with more classes or clauses. These operations also result in substantial overhead in terms of resource and power, especially for small TM models like those for Iris. These findings indicate that the popcount and comparison operations are a bottleneck in TM implementations. 1) Latency: Fig. 9 (a) shows that while the asynchronous TM with time-domain popcount has higher latency for Iris, it outperforms adder-based implementations in larger models (especially the MNIST 50 clauses case), reducing overall inference latency by up to 38 . To explain this trend, we further analyze the impact of TM model scaling on the total latency of popcount and comparison, as shown in Fig. 10, providing a general perspective rather than focusing on a specific dataset or model. Specifically, the latency is influenced by the number of clauses and the number of classes, which primarily determine the proportional latency contributions of popcount and comparison, respectively. Impact of the number of clauses on popcount latency: In Fig. 10 (a), the popcount latency-and consequently, the total latency, since the comparison latency remains constant for a fixed number of classes-follows a logarithmic increase with more clauses in the generic adder-based design, as the depth of the adder tree grows logarithmically with the input length. For 6 Generic FPT 18 This work 0 5 10 15 5.3 53.8 Iris, 10 clauses Inference latency (ns) Generic FPT 18 This work 0 10 20 30 10.5 80 Iris, 50 clauses Generic FPT 18 This work 0 20 40 -38 -22.9 MNIST, 50 clauses Generic FPT 18 This work 0 20 40 60 -17.5 19.5 MNIST, 100 clauses Overall Popcount (a) Generic FPT 18 This work ASYNC 21 0 100 200 300 50.8 10.1 -80.6 Iris, 10 clauses LUTs and FFs Overall Popcount Generic FPT 18 This work ASYNC 21 0 500 1,000 -14.3 -3.8 -81.8 Iris, 50 clauses Generic FPT 18 This work ASYNC 21 0 1,000 2,000 3,000 4,000 -10.8 -10.6 -84.3 MNIST, 50 clauses Generic FPT 18 This work ASYNC 21 0 2,000 4,000 6,000 -15 -9.2 -85.1 MNIST, 100 clauses (b) Generic FPT 18 This work 0 2 4 6 8 -22.2 40 Iris, 50 clauses Dynamic power (mW) Generic FPT 18 This work 0 10 20 30 40 -32.5 -14.8 MNIST, 50 clauses Generic FPT 18 This work 0 20 40 60 -43.1 -7.5 MNIST, 100 clauses Overall Popcount (c) Fig. 9: Comparison of (a) inference latency, (b) resource utilization, and (c) dynamic power for TMs across different implementations: generic implementations using Vivado, asynchronous implementations with time-domain popcount, and implementations incorporating state-of-the-art popcount from FPT 18 [6] and ASYNC 21 [24]. the time-domain popcount, latency increases linearly with the number of clauses, since the PDL length grows proportionally. The worst case assumes all delay elements select the high- latency net, while the average case is estimated using 1,000 MNIST samples. The 3σ interval in the average case suggests that reaching the worst-case latency is highly improbable, especially for larger TM models. For FPT 18, latency also scales linearly with the number of clauses due to its ripple-carry adder-like structure, where the critical path length is determined by the input size. The increase is slightly smaller than that of the time-domain popcount in the average case, as the high-latency nets in PDLs introduce some additional overhead. These trends suggest that for large input vectors, adder-based designs may have a latency advantage over the time-domain popcount. Impact of the number of classes on comparison latency: Fig. 10 (b) shows that overall latency in adder-based de- signs increases linearly with the number of classes, because each class sum must be sequentially compared, increasing comparison latency, with the popcount latency unchanged. In contrast, time-domain popcount maintains nearly constant latency, with arbiters detecting transition arrival times, and delay increases remain negligible with more arbiter levels for larger comparisons. Thus, the time-domain popcount is particularly advanta- 20 40 60 80 100 20 40 60 80 Number of clauses Latency (ns) Generic FPT 18 20 40 60 80 100 20 40 60 80 Time-domain 3σ range Number of clauses Worst Average (a) 2 4 6 8 10 20 40 60 80 Number of classes Latency (ns) Generic FPT 18 2 4 6 8 10 20 40 60 80 Time-domain Number of classes Worst Average (b) Fig. 10: Latency vs. (a) clauses (6 classes) and (b) classes (100 clauses) across different popcount implementations. geous for tasks requiring comparisons across multiple entities, such as multi-class classifications. For TMs, this suggests even 7 greater latency reductions in tasks with more classes than MNIST, compared to adder-based implementations. 2) Resource utilization: According to Fig. 9 (b), the pro- posed asynchronous TM consumes the least resources in all cases except for the smallest model (10-clause TM for Iris), achieving up to a 15 reduction in overall resource utilization. Notably, the time-domain popcount significantly reduces re- source usage compared to ASYNC 21, despite both operating in asynchronous architectures. ASYNC 21 s dual-rail adder- based popcount introduces substantial overhead beyond stan- dard adders. While its completion detection largely enhances throughput [24], it comes at a high resource cost. To assess whether this resource reduction scales with model size, we analyze resource usage across varying numbers of clauses and classes, as shown in Fig. 11. In all implementa- tions, resource utilization increases linearly with model size, but the time-domain popcount consistently exhibits the small- est increment. This indicates that the resource savings achieved by the time-domain popcount is consistently maintained for larger models compared to adder-based designs. 20 40 60 80 100 0 250 500 750 1,000 Number of clauses LUTs and FFs Time-domain Generic FPT 18 (a) 2 4 6 8 10 500 1,000 1,500 Number of classes LUTs and FFs Time-domain Generic FPT 18 (b) Fig. 11: Resource vs. (a) clauses (6 classes) and (b) classes (100 clauses) across different popcount implementations. 3) Dynamic power: In Fig. 9 (c), we evaluate the dynamic power for all cases except for the 10-clause TM for Iris, as its power consumption is too small for meaningful comparison. The presented asynchronous TM achieves the lowest dynamic power consumption across both MNIST models, with reduc- tions of up to 43.1 . Interestingly, when comparing FPT 18 and our design for the MNIST cases, the FPT 18 popcount itself exhibits lower dynamic power than the time-domain popcount. However, the overall architecture incorporating the time-domain popcount consumes less dynamic power than the full architecture of FPT 18. This suggests that the asyn- chronous mechanism, by eliminating the need for a clock signal, contributes significantly to dynamic power reduction. We evaluate the dynamic power of different popcount im- plementations while scaling the number of TM clauses and classes, as shown in Fig. 12. By definition, dynamic power is largely influenced by switching activity, meaning the power values reported in Fig. 9 (c) are dependent on the dataset and input samples. To investigate this impact, we measure power consumption under two sets of input vectors, leading to switching activity factors of 0.1 and 0.5. 20 40 60 80 100 0 5 10 15 Switching activity factor 0.1 Number of clauses Dynamic power (mW) 20 40 60 80 100 0 20 40 Switching activity factor 0.5 Number of clauses Time-domain Generic FPT 18 (a) 2 4 6 8 10 10 20 Switching activity factor 0.1 Number of classes Dynamic power (mW) Time-domain Generic FPT 18 2 4 6 8 10 0 20 40 60 80 Switching activity factor 0.5 Number of classes (b) Fig. 12: Power vs. (a) clauses (6 classes) and (b) classes (100 clauses) across different popcount implementations. As shown in Fig. 12, for low switching activity (0.1), adder- based popcount consumes less dynamic power due to reduced circuit switching. However, in the time-domain popcount, tran- sitions occur in all delay elements during each cycle, leading to relatively higher power consumption. On the other hand, adder-based popcount is highly sensitive to switching activity, with a significant increase in dynamic power when the switch- ing activity factor rises to 0.5. In contrast, the time-domain popcount remains much less affected by increased switching activity, ultimately becoming the most power-efficient option. This more stable dynamic power behavior makes the time- domain popcount advantageous in scenarios where predictable energy consumption is critical. The reduced sensitivity to switching activity simplifies power management, which is par- ticularly beneficial for battery-powered or energy-constrained devices, where TMs and other low-complexity ML algorithms are more likely to be deployed. V. CONCLUSIONS AND FUTURE WORK We present an efficient FPGA implementation of time- domain popcount and comparison. This design leverages carefully engineered PDLs to achieve a highly linear and monotonic relationship between input Hamming weight and propagation delay. We demonstrate that the time-domain pop- count can be practically implemented on an FPGA while maintaining lossless accuracy for low-complexity machine learning algorithms like TMs, serving as a case study in this paper. Exploiting the natural compatibility of the time-domain popcount with asynchronous architectures, we implement an asynchronous TM that achieves up to 38 lower inference latency particularly for classification tasks with many classes, consistently reduces resource utilization by up to 15 , and lowers dynamic power consumption by up to 43.1 , while also exhibiting more stable power behavior compared to TMs using conventional adder-based popcount. 8 For future work, we will extend this approach to an asyn- chronous pipelined BNN architecture. As discussed in Section IV-A, the design can be adapted for pipelined architectures with minimal modifications. The output layer can follow a similar structure to Fig. 7, while for hidden layers, each neuron can be assigned a dedicated PDL, with inputs derived from synapse outputs computed via XNOR. Sign activation can be performed using a shared PDL with an equal number of ones and zeros as a neutral latency reference, with an arbiter determining neuron activation based on the timing relative to the neutral PDL. ACKNOWLEDGEMENT This work was supported by the Engineering and Phys- ical Sciences Research Council (EPSRC) under Grant EP X039943 1 and Grant EP X036006 1. REFERENCES [1] O.-C. Granmo, The Tsetlin machine a game theoretic bandit driven approach to optimal pattern recognition with propositional logic, arXiv preprint arXiv:1804.01508, 2018. [2] M. Courbariaux et al., Binarized neural networks: Training deep neural networks with weights and activations constrained to 1 or -1, arXiv preprint arXiv:1602.02830, 2016. [3] J. Anderson et al., Photonic processor for fully discretized neural networks, in 30th Int. Conf. on Appl.-Specific Syst., Architectures and Processors (ASAP), vol. 2160. IEEE, 2019, pp. 25 32. [4] T. Tanigawa et al., Efficient FPGA implementation of binarized neural networks based on generalized parallel counter tree, in Proc. the Workshop on Synthesis And Syst. Integration of Mixed Information Technol. (SASIMI), 2024, pp. 32 37. [5] Z. Li et al., FPGA logic cell improvements for popcount computation in BNN, in 16th Int. Conf. on Solid-State Integrated Circuit Technol. (ICSICT). IEEE, 2022, pp. 1 3. [6] J. H. Kim et al., FPGA architecture enhancements for efficient BNN implementation, in Int. Conf. on Field-Programmable Technol. (FPT). IEEE, 2018, pp. 214 221. [7] T. Ma et al., FPGA optimized architecture of XNOR-POPCOUNT, in 2nd Int. Conf. on Computing, Commun., Perception and Quantum Technol. (CCPQT). IEEE, 2023, pp. 235 239. [8] M. Singh et al., MOUSETRAP: High-speed transition-signaling asyn- chronous pipelines, IEEE Trans. Very Large Scale Integr. (VLSI) Syst., vol. 15, no. 6, pp. 684 698, 2007. [9] A. Dalalah et al., New hardware architecture for bit-counting, in Proc. of the 5th WSEAS Int. Conf. on Applied comput. sci., 2006, pp. 118 128. [10] S. Liang et al., FP-BNN: Binarized neural network on FPGA, Neuro- computing, vol. 275, pp. 1072 1086, 2018. [11] V. A. Pedroni, Compact hamming-comparator-based rank order filter for digital VLSI and FPGA implementations, in IEEE Int. Symp. on Circuits and Syst., vol. 2. IEEE, 2004, pp. II 585. [12] M. Majzoobi et al., FPGA PUF using programmable delay lines, in IEEE Int. workshop on inf. forensics and Secur. IEEE, 2010, pp. 1 6. [13] M. H. Mahalat et al., An efficient implementation of arbiter PUF on FPGA for IoT application, in 32nd IEEE Int. Syst.-on-Chip Conf. (SOCC). IEEE, 2019, pp. 324 329. [14] N. N. Anandakumar et al., Implementation of efficient XOR arbiter PUF on FPGA with enhanced uniqueness and security, IEEE Access, vol. 10, pp. 129 832 129 842, 2022. [15] D. P. Sahoo et al., Towards ideal arbiter PUF design on Xilinx FPGA: A practitioner s perspective, in Euromicro Conf. on Digital Syst. Design. IEEE, 2015, pp. 559 562. [16] T. Lan et al., An asynchronous winner-takes-all arbitration architecture for Tsetlin machine acceleration, in 22nd Interregional NEWCAS Conf. (NEWCAS). IEEE, 2024, pp. 16 20. [17] Vivado Design Suite Properties Reference Guide, UG912 ed., AMD Xilinx, June 2022, available at manuals xilinx2022 1 ug912- vivado-properties.pdf. [18] J. R. Stevens et al., Softermax: Hardware software co-design of an efficient softmax for transformers, in 58th ACM IEEE Design Automat. Conf. (DAC), 2021, pp. 469 474. [19] M. Majzoobi et al., Rapid FPGA characterization using clock synthesis and signal sparsity, in Int. Test Conf. (ITC), 2010, pp. 1 10. [20] R. A. Fisher, Iris, UCI Mach. Learning Repository, 1988, DOI: [21] L. Deng, The MNIST database of handwritten digit images for machine learning research, IEEE Signal Process. Mag., vol. 29, no. 6, pp. 141 142, 2012. [22] T. Rahman et al., Data booleanization for energy efficient on-chip learning using logic driven AI, in Int. Symp. on the Tsetlin Mach. (ISTM). Grimstad, Norway: IEEE, 2022, pp. 29 36. [23] O. Tarasyuk et al., Systematic search for optimal hyper-parameters of the tsetlin machine on MNIST dataset, in Int. Symp. on the Tsetlin Mach. (ISTM). IEEE, 2023, pp. 1 8. [24] A. Wheeldon et al., Self-timed reinforcement learning using tsetlin machine, in 27th Int. Symp. on Asynchronous Circuits and Syst. (ASYNC). IEEE, 2021, pp. 40 47. 9\n\n=== SEGMENTS ===\n\n--- Segment 1 ---\narXiv:2505.02181v1 [cs.LG] 4 May 2025 PREPRINT - Accepted at IEEE International Symposium on Asynchronous Circuits and Systems (ASYNC) 2025 Efficient FPGA Implementation of Time-Domain Popcount for Low-Complexity Machine Learning Shengyu Duan , Marcos L. L. Sartori , Rishad Shafik , Alex Yakovlev , Emre Ozer Microsystems Research Group, Newcastle University, Newcastle upon Tyne, UK Pragmatic Semiconductor, Cambridge, UK {shengyu.duan, marcos.sartori, rishad.shafik, alex.yakovlev}.newcastle.ac.uk Abstract Population count (popcount) is a crucial operation for many low-complexity machine learning (ML) algorithms, in- cluding Tsetlin Machine (TM)-a promising new ML method, par- ticularly well-suited for solving classification tasks. The inference mechanism in TM consists of propositional logic-based structures within each class, followed by a majority voting scheme, which makes the classification decision. In TM, the voters are the outputs of Boolean clauses. The voting mechanism comprises two operations: popcount for each class and determining the class with the maximum vote by means of an argmax operation. While TMs offer a lightweight ML alternative, their per- formance is often limited by the high computational cost of popcount and comparison required to produce the argmax result. In this paper, we propose an innovative approach to accelerate and optimize these operations by performing them in the time domain. Our time-domain implementation uses programmable delay lines (PDLs) and arbiters to efficiently manage these tasks through delay-based mechanisms. We also present an FPGA design flow for practical implementation of the time-domain popcount, addressing delay skew and ensuring that the behavior matches that of the model s intended functionality. By leveraging the natural compatibility of the proposed popcount with asyn- chronous architectures, we demonstrate significant improvements in an asynchronous TM, including up to 38 reduction in latency, 43.1 reduction in dynamic power, and 15 savings in resource utilization, compared to synchronous TMs using adder- based popcount. Index Terms Popcount, Machine Learning, Tsetlin Machine, Programmable Delay Line, FPGA. I.\n\n--- Segment 2 ---\nIndex Terms Popcount, Machine Learning, Tsetlin Machine, Programmable Delay Line, FPGA. I. INTRODUCTION There has been a shift towards low-complexity machine learning (ML) algorithms, offering competitive performance with fewer resources than deep neural networks. Tsetlin Ma- chines (TMs) [1] and Binarized Neural Networks (BNNs) [2] are two prominent alternatives that leverage bit-wise oper- ations, making them highly suitable for implementation on Field Programmable Gate Arrays (FPGAs). A TM is inherently logic-based, performing classification through propositional logic with Boolean inputs (Fig. 1 (a)). In contrast, a BNN represents an extreme case of quantized deep neural networks, encoding values with a single bit ( 1 -1) and simplifying multiplications using XNOR operations (Fig. 1 (b)). Population count (otherwise known as popcount) and com- parison (argmax) are critical operations in both TMs and Class 1 Input vector: [x0 x1] Class 0 x0 x0 x1 x1 x0 x0 x1 x1 x0 x0 x1 x1 x0 x0 x1 x1 Clauses 1 -1 1 -1 P Popcount x: Include x: Exclude ... Argmax ... Predicted class (a) Input vector [x0 x1 ...] ... 1 P Popcount Sign Output (b) Fig. 1: (a) TMs, where each TM is assigned to a certain class and each clause has been trained to recognize a pattern of Boolean inputs, represented by propositional logic. Popcount counts the number of clauses supporting ( 1) and opposing (-1) each class, with the classification determined by the class with the highest popcount, using argmax. (b) A BNN neuron. x0 and x1 are input features or activation values. BNNs. In a TM, these operations function as a majority vote mechanism to determine classification outcomes (Fig. 1 (a)). On the other hand, in a BNN, popcount serves as the accumulation function for each neuron, followed by a comparator that applies the sign function by comparing the result to zero for activation (Fig. 1 (b)).\n\n--- Segment 3 ---\nOn the other hand, in a BNN, popcount serves as the accumulation function for each neuron, followed by a comparator that applies the sign function by comparing the result to zero for activation (Fig. 1 (b)). However, studies have identified popcount and comparison as bottlenecks in BNN implementations, increasing latency and resource consumption due to their relatively low hardware efficiency compared to logic operations [3], [4]. For the first time, we will present these operations as bottlenecks for TMs in Section IV. To overcome this bottleneck, some efforts have been dedi- cated to developing cost-efficient and high-performance pop- count accelerators and compressors, with a primary focus on adder-based architectures [4] [7]. In this paper, we introduce a paradigm shift by transitioning popcount and argmax oper- ations to the time domain. For ML algorithms including TMs and BNNs, the core functionality remains unaffected by this transformation, as their outputs are typically determined by relative magnitudes rather than absolute values. The basic principle of our method is as follows: the higher the popcount the smaller the delay of the corresponding delay- line. This combination of time-domain functionality naturally suits the use of asynchronous logic design. To implement this 1 method in FPGA, we use programmable delay lines (PDLs), constructed using Lookup Tables (LUTs), to function as popu- lation counters (pop counters), while arbiters are employed as comparators that respond based on signal arrival times. This operation s output is one-hot, and computations are interleaved with spacers, making the use of completion detectors the natural choice. Furthermore, we propose a design flow for placement, pin assignment, and routing of PDLs to mitigate delay skew introduced by generic FPGA implementations. We leverage this advantage to design asynchronous cir- cuit for the TM inference using MOUSETRAP [8] on a Xilinx Zynq XC7Z020 FPGA (PYNQ-Z1), using a single- rail bundled datapath and two-phase handshake protocol. Our case study demonstrates a low latency and energy-efficient inference process for asynchronous TMs, achieved through the implementation of time-domain popcount.\n\n--- Segment 4 ---\nWe leverage this advantage to design asynchronous cir- cuit for the TM inference using MOUSETRAP [8] on a Xilinx Zynq XC7Z020 FPGA (PYNQ-Z1), using a single- rail bundled datapath and two-phase handshake protocol. Our case study demonstrates a low latency and energy-efficient inference process for asynchronous TMs, achieved through the implementation of time-domain popcount. This results in enhanced throughput (up to 38 lower latency), reduced power consumption (up to 43.1 less power), and lower resource utilization (up to 15 less) compared to conventional adder-based popcount implementations, particularly for multi- class classification tasks that involve comparisons across many entities. We make the following key contributions: A novel time-domain circuit design for popcount and comparison, enabling cost-efficient and scalable imple- mentations for TMs and possibly BNNs. A FPGA design flow for implementing time-domain popcount, addressing propagation delay uncertainties to ensure reliable and efficient performance. High-performance asynchronous architectures for TMs with time-domain pop counters and comparators, signif- icantly improving throughput and power efficiency. The paper is organized as follows: Section II reviews related work on popcount circuits and PDLs. Section III presents our time-domain popcount and comparison design and FPGA implementation flow. Section IV showcases an asynchronous TM case study, compares it with existing approaches. Section V concludes the paper and outlines future work. II. RELATED WORK We overview state-of-the-art digital popcount designs and PDLs, focusing on their suitability for FPGA implementation. A. Popcount Conventional popcount designs primarily rely on binary full adder trees to sum input bits. Recent research has largely focused on optimizing wide adders, while efforts to accelerate or compress popcount adders remain limited. One improve- ment is an 8-bit popcount design that reduces resource usage [9]. However, for longer input vectors, this approach requires additional levels to aggregate multiple 8-bit popcount results, ultimately leading to a tree-based adder architecture. A more recent approach leverages 6-input LUTs in mod- ern FPGAs to compress popcount trees, where three LUTs collectively function as a 6-bit popcounter, producing a 3-bit output [10].\n\n--- Segment 5 ---\nHowever, for longer input vectors, this approach requires additional levels to aggregate multiple 8-bit popcount results, ultimately leading to a tree-based adder architecture. A more recent approach leverages 6-input LUTs in mod- ern FPGAs to compress popcount trees, where three LUTs collectively function as a 6-bit popcounter, producing a 3-bit output [10]. Another design, optimized based on ripple carry adders, introduces an additional chain to propagate the sum of each full adder [6]. While this method achieves modest resource savings, it increases latency compared to conventional popcount trees. Further optimizations based on these works have been proposed by sharing logic elements [5], [7]. Most existing adder-based approaches remain within a sim- ilar design space, where improving one metric typically comes at the expense of others. More importantly, the comparison of multiple popcount results an essential operation in applica- tions such as TMs and the output layer of BNNs introduces significant overhead in terms of latency and resource con- sumption when using digital comparators [11]. In ML tasks involving a large number of classes, this comparison (argmax) becomes a major bottleneck. B. Programmable Delay Line (PDL) PDLs have been practically implemented on FPGAs in previous works, utilizing a cascade of programmable delay elements, where each element consists of a single LUT that buffers or inverts an input signal with its delay multiplexed by other inputs [12] [15]. These PDLs are commonly used for arbiter physical unclonable functions (PUFs), which compare signals racing through two symmetric PDLs and generate responses based on cumulative delays of all units in each path. However, PDLs originally for arbiter PUFs cannot be di- rectly applied for time-domain popcount. First, PUF outputs are determined by specific input vector, whereas popcount outputs depend on input Hamming weight; for example, the output should remain the same for input vectors 0...01 and 10...0 in popcount, which is not the case for PUFs. Second, while PUFs exploit intrinsic process variations to generate device-specific responses, popcount must mitigate these variations for consistency and device-independency. A recent study proposed using PDLs specifically for TM popcount followed by asynchronous arbitration for argmax [16].\n\n--- Segment 6 ---\nSecond, while PUFs exploit intrinsic process variations to generate device-specific responses, popcount must mitigate these variations for consistency and device-independency. A recent study proposed using PDLs specifically for TM popcount followed by asynchronous arbitration for argmax [16]. However, this work lacks validation through physical implementation of integrated circuit or FPGA. We emphasize that achieving accurate popcount using PDLs requires both structural and physical uniformity, the latter of which can only be ensured through careful physical design. On FPGAs, rout- ing delays dominate over logic delays, necessitating precise placement and routing to maintain an unskewed relationship between input Hamming weight and popcount. This effort is crucial for the deployment of PDLs for popcount. III. TIME-DOMAIN POPCOUNT ON FPGA A. Time-domain Popcount and Comparison We present the overall architecture for the time-domain popcount and comparison in Fig. 2. 1) Overall operational mechanism: The core concept be- hind the time-domain popcount and comparison design is as follows. Each PDL functions as a converter, transforming a binary code (input vector) into a cumulative delay (popcount result) based on its corresponding Hamming weight. As illustrated in Fig. 2, when comparing the popcount of two binary codes, these codes are represented by the signals 2 High-latency net Low-latency net D Q 0 1 S up[0] ... 0 1 S up[n-1] PDL Output D Q 0 1 S lo[0] ... 0 1 S lo[n-1] Delay element Arbiter Start Completion I0 0 1 1 1 INIT[7:0]: 0 1 0 0 0 1 1 0 0 1 1 0 I1 0 1 0 1 I2 0 1 output LUT select Configurable delay skew A1 A2 A3 A4 A5 A6 400 600 800 1,000 1,013 811 648 774 414 355 Physical pin Minimal net delay (ps) Physical pin assignment for logical pin I0 I1 Fig. 2: Time-domain popcount and comparison, implemented by PDL and arbiter, respectively. S up and S lo, corresponding to the upper and lower PDLs, respectively. Each bit in these codes is processed using two elementary delay units: one long (high-latency net) and one short (low-latency net).\n\n--- Segment 7 ---\nS up and S lo, corresponding to the upper and lower PDLs, respectively. Each bit in these codes is processed using two elementary delay units: one long (high-latency net) and one short (low-latency net). The delay path selects either the longer or shorter delay unit via a multiplexer: a bit of S up S lo equal to 0 1 inserts the longer shorter delay unit. Once all input binary codes are valid and ready for conver- sion, a start signal propagates from the left to the right end of all PDLs. The delay incurred by each PDL is inversely proportional to the Hamming weight of its corresponding binary code. In other words, a binary code with a higher popcount reaches the end earlier than one with a lower popcount. The arrival times at the right ends of the two PDLs are captured by an arbiter, implementing an argmax operation. Specifically, in the case of TMs, the input binary code for a PDL is derived from the outputs of all clauses belonging to a particular class. As shown in Fig. 1 (a), half of the clauses vote for the class, while the other half vote against it. To handle this polarity within a single PDL, an input bit from a clause supporting the class (positive clause) selects the longer shorter delay unit if it is 0 1 , whereas for a clause opposing the class (negative clause), the selection is reversed: a 1 0 input inserts the longer shorter delay unit. 2) PDL: Time-domain popcount is implemented using PDLs consisting of cascaded delay elements, each realized with a single LUT, similar to [12] [15]. However, our design places a strong emphasis on ensuring structurally symmetric PDLs and physically identical delay elements. Across all PDLs, the start signal triggered by a rising or falling transition is synchronized using D flip-flops (FFs) running at the maximum clock frequency. This synchroniza- tion is essential, as the input transition may be distributed across a large number of PDLs, which otherwise leads to uneven signal propagation. The potential skew caused by fan- out is mitigated by allowing the transition to propagate only at the clock edge, which is uniformly distributed to all FFs through clock tree synthesis.\n\n--- Segment 8 ---\nThis synchroniza- tion is essential, as the input transition may be distributed across a large number of PDLs, which otherwise leads to uneven signal propagation. The potential skew caused by fan- out is mitigated by allowing the transition to propagate only at the clock edge, which is uniformly distributed to all FFs through clock tree synthesis. Each delay element is implemented by configuring a LUT to function as a multiplexer with two inputs, both connected to the output of the preceding logic. These two inputs have different propagation delays, realized by routing them through high-latency and low-latency nets, respectively, as described in Section III-B. We emphasize that a specific logical pin mapping process is required to assign the inputs to physical pins, particularly for Xilinx FPGAs, where pins A6 and A5 are faster than the others, as reported in [17]. To validate this, we evaluate the minimal net delay for all physical pins using Vivado, as shown in Fig. 2, to determine the optimal pinout selection: the low-latency and high-latency nets are assigned to the fastest and second-fastest physical pins, respectively. The delay of the high-latency net is then adjusted during the routing phase to minimize the delay difference relative to the low- latency net, achieving minimal overall latency while ensuring adequate granularity and resolution for the task. 3) Arbiter: A NAND SR latch is employed as the arbiter to respond to the race between two PDLs, outputting 0 or 1 based on which chain introduces the rising transition first. The latch, constructed from two cross-coupled NAND gates, ensures symmetric placement relative to the two PDLs. An OR gate generates a completion signal to indicate the comparison is complete. For comparisons involving more than two PDLs, additional levels of arbiters are added, with the completion signal from the previous level serving as input to the next. For falling transitions, a separate arbiter is used, comprising a NOR SR latch and an AND gate to produce the comparison result and completion signal, respectively. Metastability may occur if two PDLs trigger output tran- sitions at nearly the same time.\n\n--- Segment 9 ---\nFor falling transitions, a separate arbiter is used, comprising a NOR SR latch and an AND gate to produce the comparison result and completion signal, respectively. Metastability may occur if two PDLs trigger output tran- sitions at nearly the same time. However, this can usually be resolved by increasing the delay difference between high- and low-latency nets of all delay elements, which improves resolution and ensures a sufficient gap between the transition arrival times, even when the two PDLs receive a nearly identical (but not the same) ones from their corresponding input vectors. Therefore, metastability may only occur if two PDLs receive equal number of ones (same Hamming weight). For certain ML operations like argmax, where two inputs are identical, the argmax function is designed to either arbitrarily select one input or consistently return a specific index. In both cases, this might be interpreted as an incorrect decision, as the result would essentially be based on a random or predetermined guess (basically, the result of inference may not match the class label in the training set)1. B. Implementation We present the FPGA implementation flow for the time- domain popcount design in Fig. 3. While some steps require manual intervention, these can be performed using the example 1The discussion of the interpretation of the classification metastability is outside the scope of this paper. It is worth noting that the problem of non- unique classification using argmax is sometimes mitigated by the techniques such as Softmax and Softermax [18]. 3 Tcl scripts provided as references. Each step is repeated for every delay element.\n\n--- Segment 10 ---\n3 Tcl scripts provided as references. Each step is repeated for every delay element. Placement Place delay element in specified site and slice set property BEL D6LUT [get cells PDL0 0 MUX] set property LOC SLICE X74Y0 [get cells PDL0 0 MUX] Example scripts Pin Assignment Map logical pins to physical pins set property LOCK PINS {I1:A6 I0:A5} [get cells PDL0 0 MUX] Example scripts Routing route design -unroute Remove existing routing Delay-driven routing for consistent delay skew route design -pins [get pins PDL0 0 MUX I1] -max delay 500 route design -pins [get pins PDL0 0 MUX I0] -max delay 800 -min delay 700 route design -preserve Preserve existing routing; route the rest set property is route fixed 1 [get nets PDL0 0 I1 PDL0 0 I0] Fix routing Example scripts Fig. 3: Implementation flow for time-domain popcount with example Xilinx Tcl scripts. 1) Placement: FPGAs consist of numerous identical logic components, which we utilize to implement uniform PDLs and delay elements. Symmetric PDLs are achieved by mapping them onto identical geometric components. Fig. 4 illustrates an example of placement on Xilinx FPGA, where PDLs are aligned vertically, with each delay element assigned to a configurable logic block (CLB). Alternative geometric place- ments are also possible, as long as the symmetry of the PDLs is preserved. Similarly, the cross-coupled NAND gates in an arbiter must be symmetrically positioned relative to the corresponding PDLs. This placement strategy increases the likelihood of achieving identical routing in later design stages. Furthermore, two cascaded delay elements are placed in adjacent CLBs, minimizing the geometric distance between them to reduce net delay for their interconnections. LUTs Slice CLB Switchbox PDL : Delay element PDL Fig. 4: PDL placement on Xilinx FPGA, where each CLB consists of two slices, and each slice contains four LUTs. Each PDL is mapped to CLBs positioned identically relative to their neighboring switchboxes. Delay elements are consistently placed in the same relative position, specifically within a designated LUT in a particular slice of each CLB.\n\n--- Segment 11 ---\nEach PDL is mapped to CLBs positioned identically relative to their neighboring switchboxes. Delay elements are consistently placed in the same relative position, specifically within a designated LUT in a particular slice of each CLB. 2) Pin assignment: As explained in Section III-A 2), the inputs with low- and high-latency nets of a delay element are initially mapped to the fastest and second-fastest physical pins of a LUT, respectively. This minimizes overall latency and ensures sufficient delay resolution during the routing process. 3) Routing: For each delay element, we route the low- and high-latency nets by specifying the delay range, as shown in Fig. 3. With all delay elements placed at identical geometric positions within their respective CLBs and cascaded delay elements aligned relative to each other, applying the same delay ranges ensures symmetric routing across all PDLs and uniform routing for all delay elements within each PDL. This is demonstrated in Fig. 5, captured from Vivado device view for two implemented PDLs, with routing paths highlighted. For each arbiter s two NAND gates, we specify identical physical pins, and apply the same delay constraints for routing. Similarly, we impose equal delay constraints on both inputs of each NAND gate. PDL CLBLL L X68Y0 CLBLL L X68Y1 CLBLL L X68Y2 INT L X68Y0 INT L X68Y1 INT L X68Y2 INT R X69Y0 INT R X69Y1 INT R X69Y2 CLBLL L X70Y0 CLBLL L X70Y1 CLBLL L X70Y2 INT L X70Y0 INT L X70Y1 INT L X70Y2 CLBLM R X69Y0 CLBLM R X69Y1 CLBLM R X69Y2 Fig. 5: Symmetric PDL and delay element layout. 4) Evaluation of Hamming weight response: An ideal time-domain popcount requires a monotonically decreasing propagation delay through the PDL as the input Hamming weight increases. We assess the likelihood of achieving this monotonic behavior in a practical implementation, considering the impact of process and environmental variations. Specifically, we implement a PDL with 150 delay elements using the proposed design flow and measure its overall propa- gation delay on an FPGA board.\n\n--- Segment 12 ---\nWe assess the likelihood of achieving this monotonic behavior in a practical implementation, considering the impact of process and environmental variations. Specifically, we implement a PDL with 150 delay elements using the proposed design flow and measure its overall propa- gation delay on an FPGA board. The measurement follows the delay characterization method from [19], with varying input Hamming weights. Fig. 6 presents the measured delays for two PDLs, where the delay difference between the low- and high-latency nets is set to approximately 60 ps and 600 ps. For each case, we compute Spearman s rank correlation coefficient (Spearman s ρ), where -1 1 indicates a perfectly decreasing increasing monotonic function. As shown, both cases exhibit a highly linear delay reduction as the Hamming weight increases, with Spearman s ρ extremely close to -1. Furthermore, increasing the delay difference between the low- and high-latency nets further strengthens the monotonicity. While a perfect linear relationship between delay and Ham- ming weight is impossible due to intra-die process, voltage 4 0 20 40 60 80 100 120 140 20 30 40 50 60 Hamming weight Propagation delay (ns) Delay difference: 60 ps, Spearman s ρ -0.9897 Delay difference: 600 ps, Spearman s ρ -0.9981 140 145 150 21 22 23 24 Fig. 6: PDL propagation delay vs. input Hamming weight. and temperature variations, the time-domain popcount can maintain sufficient accuracy by appropriately tuning the delay difference, with a trade-off in overall propagation delay as needed. IV. TM CASE STUDY A. Asynchronous TM with Time-Domain Popcount For the time-domain popcount presented, the critical path is determined by all delay elements with their corresponding high-latency nets, meaning the worst-case delay is primarily influenced by the cumulative delay of the high-latency nets. In tasks requiring high-accuracy popcount, the high-latency net delay must be increased to mitigate metastability in the arbiter and ensure sufficient timing resolution for the PDL. This increase in delay, however, leads to increased latency and reduced throughput when the time-domain popcount is used in a synchronous design. Fortunately, the time-domain popcount design is naturally compatible with an asynchronous handshake protocol.\n\n--- Segment 13 ---\nThis increase in delay, however, leads to increased latency and reduced throughput when the time-domain popcount is used in a synchronous design. Fortunately, the time-domain popcount design is naturally compatible with an asynchronous handshake protocol. The input transition of a PDL can be triggered directly by a single-bit request, while the output of either the PDL or the arbiter can be used to generate an acknowledgement or a new request, enabling the next actions with minimal additional control logic. In this configuration, the overall latency depends on the specific input vectors for the PDLs, rather than being constrained by the worst-case delay. We present a single-rail, 2-phase asynchronous architecture for TM inference, incorporating the MOUSETRAP stage cir- cuit [8] with the time-domain popcount, as shown in Fig. 7, for the case study. This configuration enables high-speed operation through 2-phase handshaking and strong FPGA compatibility using simple logic gates for the control. Additionally, the time- domain popcount can be integrated with other asynchronous or self-timed architectures, as it effectively functions as a buffer for propagating control signals, whether level-sensitive or transition-based. In Fig. 7, the processing logic following the transparent latches consists of TM clause blocks responsible for propo- sitional logic computations, as shown in Fig. 1 (a). We adopt a bundled-data scheme for these clause computation blocks, Data latch En done req Bit latch ack delay Input vector Class 0 clauses Class 1 clauses Class 2 clauses Q D ... Select Q D ... Select Q D ... Select PDL PDL output const 0 1 Completion Output Input up Input lo Completion Output Input up Input lo Arbiter Completion Output Input up Input lo Completion Asynchronous controller Fig. 7: Asynchronous TM architecture, integrating a MOUSE- TRAP stage and time-domain popcount and comparison. requiring a bundling signal based on their worst-case delay. In FPGA, this bundling signal can be generated by appropriately setting a net delay, eliminating the need for additional logic. Each PDL receives outputs from a TM clause block for a specific class, with the bundling signal acting as the input transition. The clause output selects whether the propagation path follows the low- or high-latency net of a delay element.\n\n--- Segment 14 ---\nEach PDL receives outputs from a TM clause block for a specific class, with the bundling signal acting as the input transition. The clause output selects whether the propagation path follows the low- or high-latency net of a delay element. As explained in Section III-B, the connections of the low- and high-latency nets are swapped at the delay element inputs to account for clauses with positive and negative polarity. Fig. 7 illustrates a TM with three classes, requiring two lev- els of arbiters. At the first level, the lower arbiter has one input fixed at either 0 or 1, depending on whether req undergoes a rising or falling transition in a given cycle. This ensures the arbiter is only sensitive to the incoming PDL output while maintaining a symmetric arbiter tree structure. For TMs with more classes, additional arbiter levels are required. The final classification is obtained by decoding the arbiter outputs, with the last-level arbiter generating the Completion signal. The architecture features a single MOUSETRAP stage for the present single-layer TMs. done signal toggles req to initi- ate a new inference process, enabling support for batched data. A simple asynchronous controller generates ack, switching the latches from opaque to transparent based on Completion and all PDL outputs, as explained later in this section. Notably, this architecture can be adapted for a pipelined design with minimal modifications: done serves as the acknowledgment signal for the previous stage, while the asynchronous controller generates the request signal for the next pipeline stage. We specify the overall operation using a signal transition graph (STG), shown in Fig. 8. The signal transitions and their causal relationships are partially realized by the MOUSE- TRAP control (see [8]). In our design, a merge fragment based on all PDL outputs that provides the Completion signal is implemented using arbiters. A transition in the Completion triggers a change in a wait signal in the asynchronous con- troller. This wait signal temporarily halts operations until the appropriate transitions are received at all PDL outputs, as managed by a join fragment. This suspension prevents unarrived transitions from interfering with the next inference cycle. Given that sufficient timing resolution has been achieved by appropriately setting the delay differences for the delay ele- ment inputs, the falling and rising transitions of the wait signal 5 can always be met by the timing.\n\n--- Segment 15 ---\nThis suspension prevents unarrived transitions from interfering with the next inference cycle. Given that sufficient timing resolution has been achieved by appropriately setting the delay differences for the delay ele- ment inputs, the falling and rising transitions of the wait signal 5 can always be met by the timing. Note that for each inference, the overall latency is determined by the TM producing the smallest class sum; however, in practice, it rarely reaches the worst-case scenario, where all delay elements propagate with the low-latency net, as demonstrated in Section IV-C. MOUSETRAP controller Popcount and asynchronous controller req done En- En ack PDL output 2 PDL output 1 PDL output 0 wait- Completion wait Fig. 8: STG for asynchronous TM, with the dotted arc as a mandatory timing dependency not enforced by the controller. B. Experimental Setup We validate the asynchronous TM using two datasets: Iris [20] and MNIST [21] (Table I). For each dataset, a Booleaniza- tion process is first applied to convert the raw features into a set of Boolean data [22]. For Iris, each raw feature is Booleanized into three Boolean features using quantile binning, represented as a three-bit one-hot encoding, resulting in a total of 12 Boolean features. For MNIST, it is performed by applying a threshold of 75 to all grayscale values. TABLE I: Dataset, TM model and PDL details. Dataset TM PDL net delaya (ps) Classes Boolean features Clausesb (T,s) Accuracy ( ) Low- latency High- latency Iris 3 12 10 (5,1.5) 96.7 375.4 641.9 50 (7,6.5) 90 388.6 593 MNIST 10 784 50 (5,7) 94.5 402.8 603.3 100 (5,10) 95.4 371.1 632.1 a Delay to realize lossless accuracy b Number of clauses per class For Iris and MNIST, we train two TMs with 10 and 50 clauses, and 50 and 100 clauses, respectively, to assess performance across varying numbers of classes and clauses, for evaluation purpose. Higher accuracy could be achieved by using more clauses [23]. The hyperparameters T and s for TM training are chosen based on the optimal accuracy setups from [23].\n\n--- Segment 16 ---\nHigher accuracy could be achieved by using more clauses [23]. The hyperparameters T and s for TM training are chosen based on the optimal accuracy setups from [23]. For PDLs, we set the low-latency net delay to the smallest possible value and adjust the high-latency net delay using trial and error to determine the minimum delay that ensures lossless accuracy. On average, the low- and high-latency net delays are 384.5 ps and 617.6 ps, respectively, with a 233.1 ps difference. We emphasize that the proposed architecture can be applied to implement TMs for any dataset, regardless of the number of classes, clauses, or features. The trends observed in design metrics as the model scales reported in the following section are applicable to datasets beyond Iris and MNIST. All designs were implemented on a Xilinx Zynq XC7Z020 FPGA (PYNQ-Z1), featuring 53,200 LUTs and 106,400 FFs in a 28 nm technology node. The proposed architecture is compared to the following state-of-the-art designs: Generic implementation A synchronous TM archi- tecture with adder-based popcount and comparison, syn- thesized and implemented using Vivado 2024.1 s generic process. FPT 18 [6] A synchronous FPGA-based popcount circuit, originally designed for BNNs, which we recon- structed within a TM architecture for evaluation. ASYNC 21 [24] A dual-rail asynchronous TM ar- chitecture using dual-rail 8-bit pop counters, originally presented in [9]. Since this circuit is not designed for FPGA and its implementation would require extensive modifications, we compare only resource utilization by evaluating the equivalent LUT count of their pop coun- ters, synthesizing their building blocks in Vivado. C. Evaluation and Comparison We present the inference latency, resource utilization (to- tal LUTs and FFs), and dynamic power for the evaluated implementations in Fig. 9. For resource utilization, we treat LUTs and FFs equally for simplicity, although in practice, their impact on area can vary depending on the design and FPGA architecture. For the two adder-based synchronous implementations, latency, defined as the minimal clock period, is determined by the worst-case critical path delay.\n\n--- Segment 17 ---\nFor resource utilization, we treat LUTs and FFs equally for simplicity, although in practice, their impact on area can vary depending on the design and FPGA architecture. For the two adder-based synchronous implementations, latency, defined as the minimal clock period, is determined by the worst-case critical path delay. For the proposed asynchronous design, latency is measured as the average inference time over 100 samples, as it is not controlled by clock. Resource utilization and dynamic power are obtained from the Vivado implementation reports. For each metric, we highlight the proportional contribution of the popcount and comparison operations. As shown in Fig. 9 (a), in all cases, the latency due to popcount and comparison dominates the overall inference latency, with the proportion contributed by these operations increasing significantly as the model scales with more classes or clauses. These operations also result in substantial overhead in terms of resource and power, especially for small TM models like those for Iris. These findings indicate that the popcount and comparison operations are a bottleneck in TM implementations. 1) Latency: Fig. 9 (a) shows that while the asynchronous TM with time-domain popcount has higher latency for Iris, it outperforms adder-based implementations in larger models (especially the MNIST 50 clauses case), reducing overall inference latency by up to 38 . To explain this trend, we further analyze the impact of TM model scaling on the total latency of popcount and comparison, as shown in Fig. 10, providing a general perspective rather than focusing on a specific dataset or model. Specifically, the latency is influenced by the number of clauses and the number of classes, which primarily determine the proportional latency contributions of popcount and comparison, respectively. Impact of the number of clauses on popcount latency: In Fig. 10 (a), the popcount latency-and consequently, the total latency, since the comparison latency remains constant for a fixed number of classes-follows a logarithmic increase with more clauses in the generic adder-based design, as the depth of the adder tree grows logarithmically with the input length.\n\n--- Segment 18 ---\nImpact of the number of clauses on popcount latency: In Fig. 10 (a), the popcount latency-and consequently, the total latency, since the comparison latency remains constant for a fixed number of classes-follows a logarithmic increase with more clauses in the generic adder-based design, as the depth of the adder tree grows logarithmically with the input length. For 6 Generic FPT 18 This work 0 5 10 15 5.3 53.8 Iris, 10 clauses Inference latency (ns) Generic FPT 18 This work 0 10 20 30 10.5 80 Iris, 50 clauses Generic FPT 18 This work 0 20 40 -38 -22.9 MNIST, 50 clauses Generic FPT 18 This work 0 20 40 60 -17.5 19.5 MNIST, 100 clauses Overall Popcount (a) Generic FPT 18 This work ASYNC 21 0 100 200 300 50.8 10.1 -80.6 Iris, 10 clauses LUTs and FFs Overall Popcount Generic FPT 18 This work ASYNC 21 0 500 1,000 -14.3 -3.8 -81.8 Iris, 50 clauses Generic FPT 18 This work ASYNC 21 0 1,000 2,000 3,000 4,000 -10.8 -10.6 -84.3 MNIST, 50 clauses Generic FPT 18 This work ASYNC 21 0 2,000 4,000 6,000 -15 -9.2 -85.1 MNIST, 100 clauses (b) Generic FPT 18 This work 0 2 4 6 8 -22.2 40 Iris, 50 clauses Dynamic power (mW) Generic FPT 18 This work 0 10 20 30 40 -32.5 -14.8 MNIST, 50 clauses Generic FPT 18 This work 0 20 40 60 -43.1 -7.5 MNIST, 100 clauses Overall Popcount (c) Fig. 9: Comparison of (a) inference latency, (b) resource utilization, and (c) dynamic power for TMs across different implementations: generic implementations using Vivado, asynchronous implementations with time-domain popcount, and implementations incorporating state-of-the-art popcount from FPT 18 [6] and ASYNC 21 [24]. the time-domain popcount, latency increases linearly with the number of clauses, since the PDL length grows proportionally.\n\n--- Segment 19 ---\n9: Comparison of (a) inference latency, (b) resource utilization, and (c) dynamic power for TMs across different implementations: generic implementations using Vivado, asynchronous implementations with time-domain popcount, and implementations incorporating state-of-the-art popcount from FPT 18 [6] and ASYNC 21 [24]. the time-domain popcount, latency increases linearly with the number of clauses, since the PDL length grows proportionally. The worst case assumes all delay elements select the high- latency net, while the average case is estimated using 1,000 MNIST samples. The 3σ interval in the average case suggests that reaching the worst-case latency is highly improbable, especially for larger TM models. For FPT 18, latency also scales linearly with the number of clauses due to its ripple-carry adder-like structure, where the critical path length is determined by the input size. The increase is slightly smaller than that of the time-domain popcount in the average case, as the high-latency nets in PDLs introduce some additional overhead. These trends suggest that for large input vectors, adder-based designs may have a latency advantage over the time-domain popcount. Impact of the number of classes on comparison latency: Fig. 10 (b) shows that overall latency in adder-based de- signs increases linearly with the number of classes, because each class sum must be sequentially compared, increasing comparison latency, with the popcount latency unchanged. In contrast, time-domain popcount maintains nearly constant latency, with arbiters detecting transition arrival times, and delay increases remain negligible with more arbiter levels for larger comparisons. Thus, the time-domain popcount is particularly advanta- 20 40 60 80 100 20 40 60 80 Number of clauses Latency (ns) Generic FPT 18 20 40 60 80 100 20 40 60 80 Time-domain 3σ range Number of clauses Worst Average (a) 2 4 6 8 10 20 40 60 80 Number of classes Latency (ns) Generic FPT 18 2 4 6 8 10 20 40 60 80 Time-domain Number of classes Worst Average (b) Fig. 10: Latency vs. (a) clauses (6 classes) and (b) classes (100 clauses) across different popcount implementations. geous for tasks requiring comparisons across multiple entities, such as multi-class classifications.\n\n--- Segment 20 ---\n10: Latency vs. (a) clauses (6 classes) and (b) classes (100 clauses) across different popcount implementations. geous for tasks requiring comparisons across multiple entities, such as multi-class classifications. For TMs, this suggests even 7 greater latency reductions in tasks with more classes than MNIST, compared to adder-based implementations. 2) Resource utilization: According to Fig. 9 (b), the pro- posed asynchronous TM consumes the least resources in all cases except for the smallest model (10-clause TM for Iris), achieving up to a 15 reduction in overall resource utilization. Notably, the time-domain popcount significantly reduces re- source usage compared to ASYNC 21, despite both operating in asynchronous architectures. ASYNC 21 s dual-rail adder- based popcount introduces substantial overhead beyond stan- dard adders. While its completion detection largely enhances throughput [24], it comes at a high resource cost. To assess whether this resource reduction scales with model size, we analyze resource usage across varying numbers of clauses and classes, as shown in Fig. 11. In all implementa- tions, resource utilization increases linearly with model size, but the time-domain popcount consistently exhibits the small- est increment. This indicates that the resource savings achieved by the time-domain popcount is consistently maintained for larger models compared to adder-based designs. 20 40 60 80 100 0 250 500 750 1,000 Number of clauses LUTs and FFs Time-domain Generic FPT 18 (a) 2 4 6 8 10 500 1,000 1,500 Number of classes LUTs and FFs Time-domain Generic FPT 18 (b) Fig. 11: Resource vs. (a) clauses (6 classes) and (b) classes (100 clauses) across different popcount implementations. 3) Dynamic power: In Fig. 9 (c), we evaluate the dynamic power for all cases except for the 10-clause TM for Iris, as its power consumption is too small for meaningful comparison. The presented asynchronous TM achieves the lowest dynamic power consumption across both MNIST models, with reduc- tions of up to 43.1 . Interestingly, when comparing FPT 18 and our design for the MNIST cases, the FPT 18 popcount itself exhibits lower dynamic power than the time-domain popcount.\n\n--- Segment 21 ---\nThe presented asynchronous TM achieves the lowest dynamic power consumption across both MNIST models, with reduc- tions of up to 43.1 . Interestingly, when comparing FPT 18 and our design for the MNIST cases, the FPT 18 popcount itself exhibits lower dynamic power than the time-domain popcount. However, the overall architecture incorporating the time-domain popcount consumes less dynamic power than the full architecture of FPT 18. This suggests that the asyn- chronous mechanism, by eliminating the need for a clock signal, contributes significantly to dynamic power reduction. We evaluate the dynamic power of different popcount im- plementations while scaling the number of TM clauses and classes, as shown in Fig. 12. By definition, dynamic power is largely influenced by switching activity, meaning the power values reported in Fig. 9 (c) are dependent on the dataset and input samples. To investigate this impact, we measure power consumption under two sets of input vectors, leading to switching activity factors of 0.1 and 0.5. 20 40 60 80 100 0 5 10 15 Switching activity factor 0.1 Number of clauses Dynamic power (mW) 20 40 60 80 100 0 20 40 Switching activity factor 0.5 Number of clauses Time-domain Generic FPT 18 (a) 2 4 6 8 10 10 20 Switching activity factor 0.1 Number of classes Dynamic power (mW) Time-domain Generic FPT 18 2 4 6 8 10 0 20 40 60 80 Switching activity factor 0.5 Number of classes (b) Fig. 12: Power vs. (a) clauses (6 classes) and (b) classes (100 clauses) across different popcount implementations. As shown in Fig. 12, for low switching activity (0.1), adder- based popcount consumes less dynamic power due to reduced circuit switching. However, in the time-domain popcount, tran- sitions occur in all delay elements during each cycle, leading to relatively higher power consumption. On the other hand, adder-based popcount is highly sensitive to switching activity, with a significant increase in dynamic power when the switch- ing activity factor rises to 0.5. In contrast, the time-domain popcount remains much less affected by increased switching activity, ultimately becoming the most power-efficient option. This more stable dynamic power behavior makes the time- domain popcount advantageous in scenarios where predictable energy consumption is critical.\n\n--- Segment 22 ---\nIn contrast, the time-domain popcount remains much less affected by increased switching activity, ultimately becoming the most power-efficient option. This more stable dynamic power behavior makes the time- domain popcount advantageous in scenarios where predictable energy consumption is critical. The reduced sensitivity to switching activity simplifies power management, which is par- ticularly beneficial for battery-powered or energy-constrained devices, where TMs and other low-complexity ML algorithms are more likely to be deployed. V. CONCLUSIONS AND FUTURE WORK We present an efficient FPGA implementation of time- domain popcount and comparison. This design leverages carefully engineered PDLs to achieve a highly linear and monotonic relationship between input Hamming weight and propagation delay. We demonstrate that the time-domain pop- count can be practically implemented on an FPGA while maintaining lossless accuracy for low-complexity machine learning algorithms like TMs, serving as a case study in this paper. Exploiting the natural compatibility of the time-domain popcount with asynchronous architectures, we implement an asynchronous TM that achieves up to 38 lower inference latency particularly for classification tasks with many classes, consistently reduces resource utilization by up to 15 , and lowers dynamic power consumption by up to 43.1 , while also exhibiting more stable power behavior compared to TMs using conventional adder-based popcount. 8 For future work, we will extend this approach to an asyn- chronous pipelined BNN architecture. As discussed in Section IV-A, the design can be adapted for pipelined architectures with minimal modifications. The output layer can follow a similar structure to Fig. 7, while for hidden layers, each neuron can be assigned a dedicated PDL, with inputs derived from synapse outputs computed via XNOR. Sign activation can be performed using a shared PDL with an equal number of ones and zeros as a neutral latency reference, with an arbiter determining neuron activation based on the timing relative to the neutral PDL. ACKNOWLEDGEMENT This work was supported by the Engineering and Phys- ical Sciences Research Council (EPSRC) under Grant EP X039943 1 and Grant EP X036006 1. REFERENCES [1] O.-C. Granmo, The Tsetlin machine a game theoretic bandit driven approach to optimal pattern recognition with propositional logic, arXiv preprint arXiv:1804.01508, 2018.\n\n--- Segment 23 ---\nACKNOWLEDGEMENT This work was supported by the Engineering and Phys- ical Sciences Research Council (EPSRC) under Grant EP X039943 1 and Grant EP X036006 1. REFERENCES [1] O.-C. Granmo, The Tsetlin machine a game theoretic bandit driven approach to optimal pattern recognition with propositional logic, arXiv preprint arXiv:1804.01508, 2018. [2] M. Courbariaux et al., Binarized neural networks: Training deep neural networks with weights and activations constrained to 1 or -1, arXiv preprint arXiv:1602.02830, 2016. [3] J. Anderson et al., Photonic processor for fully discretized neural networks, in 30th Int. Conf. on Appl.-Specific Syst., Architectures and Processors (ASAP), vol. 2160. IEEE, 2019, pp. 25 32. [4] T. Tanigawa et al., Efficient FPGA implementation of binarized neural networks based on generalized parallel counter tree, in Proc. the Workshop on Synthesis And Syst. Integration of Mixed Information Technol. (SASIMI), 2024, pp. 32 37. [5] Z. Li et al., FPGA logic cell improvements for popcount computation in BNN, in 16th Int. Conf. on Solid-State Integrated Circuit Technol. (ICSICT). IEEE, 2022, pp. 1 3. [6] J. H. Kim et al., FPGA architecture enhancements for efficient BNN implementation, in Int. Conf. on Field-Programmable Technol. (FPT). IEEE, 2018, pp. 214 221. [7] T. Ma et al., FPGA optimized architecture of XNOR-POPCOUNT, in 2nd Int. Conf. on Computing, Commun., Perception and Quantum Technol. (CCPQT). IEEE, 2023, pp. 235 239. [8] M. Singh et al., MOUSETRAP: High-speed transition-signaling asyn- chronous pipelines, IEEE Trans. Very Large Scale Integr. (VLSI) Syst., vol. 15, no. 6, pp. 684 698, 2007.\n\n--- Segment 24 ---\n6, pp. 684 698, 2007. [9] A. Dalalah et al., New hardware architecture for bit-counting, in Proc. of the 5th WSEAS Int. Conf. on Applied comput. sci., 2006, pp. 118 128. [10] S. Liang et al., FP-BNN: Binarized neural network on FPGA, Neuro- computing, vol. 275, pp. 1072 1086, 2018. [11] V. A. Pedroni, Compact hamming-comparator-based rank order filter for digital VLSI and FPGA implementations, in IEEE Int. Symp. on Circuits and Syst., vol. 2. IEEE, 2004, pp. II 585. [12] M. Majzoobi et al., FPGA PUF using programmable delay lines, in IEEE Int. workshop on inf. forensics and Secur. IEEE, 2010, pp. 1 6. [13] M. H. Mahalat et al., An efficient implementation of arbiter PUF on FPGA for IoT application, in 32nd IEEE Int. Syst.-on-Chip Conf. (SOCC). IEEE, 2019, pp. 324 329. [14] N. N. Anandakumar et al., Implementation of efficient XOR arbiter PUF on FPGA with enhanced uniqueness and security, IEEE Access, vol. 10, pp. 129 832 129 842, 2022. [15] D. P. Sahoo et al., Towards ideal arbiter PUF design on Xilinx FPGA: A practitioner s perspective, in Euromicro Conf. on Digital Syst. Design. IEEE, 2015, pp. 559 562. [16] T. Lan et al., An asynchronous winner-takes-all arbitration architecture for Tsetlin machine acceleration, in 22nd Interregional NEWCAS Conf. (NEWCAS). IEEE, 2024, pp. 16 20. [17] Vivado Design Suite Properties Reference Guide, UG912 ed., AMD Xilinx, June 2022, available at manuals xilinx2022 1 ug912- vivado-properties.pdf.\n\n--- Segment 25 ---\n16 20. [17] Vivado Design Suite Properties Reference Guide, UG912 ed., AMD Xilinx, June 2022, available at manuals xilinx2022 1 ug912- vivado-properties.pdf. [18] J. R. Stevens et al., Softermax: Hardware software co-design of an efficient softmax for transformers, in 58th ACM IEEE Design Automat. Conf. (DAC), 2021, pp. 469 474. [19] M. Majzoobi et al., Rapid FPGA characterization using clock synthesis and signal sparsity, in Int. Test Conf. (ITC), 2010, pp. 1 10. [20] R. A. Fisher, Iris, UCI Mach. Learning Repository, 1988, DOI: [21] L. Deng, The MNIST database of handwritten digit images for machine learning research, IEEE Signal Process. Mag., vol. 29, no. 6, pp. 141 142, 2012. [22] T. Rahman et al., Data booleanization for energy efficient on-chip learning using logic driven AI, in Int. Symp. on the Tsetlin Mach. (ISTM). Grimstad, Norway: IEEE, 2022, pp. 29 36. [23] O. Tarasyuk et al., Systematic search for optimal hyper-parameters of the tsetlin machine on MNIST dataset, in Int. Symp. on the Tsetlin Mach. (ISTM). IEEE, 2023, pp. 1 8. [24] A. Wheeldon et al., Self-timed reinforcement learning using tsetlin machine, in 27th Int. Symp. on Asynchronous Circuits and Syst. (ASYNC). IEEE, 2021, pp. 40 47. 9\n\n